# Week 2 Lab: System Verilog

The difference in the range of inputs and the functionality of the programs are what I believe to be the reason why the testing approaches vary for each exercise. 

In exercise 1, the functionality of the program depended on the two-bit op code hence there were only four possible inputs (00, 01, 10, 11), allowing for simple four test cases. However, in exercise 2, the functionality of the program depended on 16 bits making it harder - and more exhausting - to make and run the entire amount of test cases. Since the functionality of the program in exercise 2 is to perform only one kind of function continously over a stream of inputs from a data bus of 16 bits, it is reasonable to test certain variations of the input. Since - by nature of the function - over multiple clock cycles, the function will be tested with different numbers. Hence, the four sample test cases to check if the program is functioning as it should. For exercise 3, the program is performing one function once, so in order to check its functionality a test input that is randomly selected at every clock cycle is needed. Contrary to exercise 2's functionality, exercise 3 does not perform a continuous function so just choosing a few test inputs is not enough, but instead choosing a *random* test input for 100 clock cycles allows testing over a variety of inputs (random selection is best since it can include edge cases).

The advantage of exercise 1's test approach is that it allows for a complete and perfect test for functionality since it tests for *every* possible input. However, after a certain input size it becomes too inefficient to cycle through every possible input as the complexity increases and with it memory space and time to test all inputs. The advantage of exercise 2's test approach is that it allows for multiple states to be tested using only a small number of inputs, but this only applies when the program performs continously over clock cycles. If the program only performs one function and then stops then the extra cycles mean nothing and waste time, furthermore, the small number of inputs is no longer sufficient to test the functionality. The advantage of exercise 3's test approach is that it does not need an extensive amount of testing to check over a variety of inputs and edge cases, however the small number of test cases, although good for brevity, may lead to missing certain edge cases and for programs that function differently after a cycle the small number is not enough. 
